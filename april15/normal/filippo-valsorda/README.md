## Foreword

I guess I went a bit hardcore on the crypto, but it's what I do as a job, and I couldn't force myself to put vulnerable code in the world, even if just for fun.

## About Crypto

This challenge effectively requires designing a crypto protocol. A lot of thought had to go into preventing reordering attacks, where the packets can be intercepted by the attacker and reordered. I ended up prepending a sequence number to the plaintext and applying a locking strategy to avoid sending/receiving out-of-order messages.

I also had to think about replay attacks: since Alice and Bob both derive the same shared key (NaCl box is just Diffie-Hellman over curve25519), a MitM can send the packets generated by Alice back to Alice as if they were coming from Bob. I solve this by having the party with the lexicographycally lower public key use even sequence numbers and vice-versa.

I had to change a test (TestReadWriterPing) since it was instantiating a SecureReader and a SecureWriter with the same key and having them talk to each other, effectively simulating a replay attack. My implementation protects against that so refuses to run such a test.

Crypto is tricky. I would expect most simple implementations to be vulnerable to at least one of the two attacks above. There are implementations in attacks_test.go that might work against other people's code if anyone wants to check.

## The Protocol

Plaintext messages are encapsulated in encrypted packets to travel on the wire. The details are pretty simple and open to interoperability.

First, the message is prepended with a big-endian fixed-length 32-bit sequence number. The party with the public key that sorts lower will use even sequence numbers, the other will use odd. The sequence numbers have to increase by 2 every message.

Then, the resulting extended plaintext is encrypted with NaCl box and a random nonce (so that even key reuse does not cause confidentiality to fall apart).

Finally, the following is sent on the wire:
- the 24 bytes nonce
- the big-endian fixed-length 32-bit length of the encrypted payload
- the encrypted payload

## Implementation Notes

The reusable code is in secureconn.go: SecureReader, SecureWriter and SecureConn. SecureConn is a net.Conn wrapper that performs the key exchange and then initializes and exposes a SecureReader and a SecureWriter. Dial and Serve are trivially implemented in main.go by just using boilerplate code and SecureConn wrapping.

SecureReader, SecureWriter and SecureConn are designed to work as any other io.Reader, io.Writer and io.ReadWriteCloser, being able to be used securely for any number of Read/Write of any size, abstracting away the underlying packet-based protocol. For example Read will transparently buffer a received packet that is longer than the requested size.

As discussed via email, SecureReader.Read returns io.EOF so to respect the io.Reader contract. This required changing the tests to use io.ReadFull. Also, as encouraged by io.Reader and done by bufio.Reader, SecureReader.Read will not fill the buffer if the received packet is shorter.

I decided not to use encoding/binary variable-length encoding because variable length fields are the enemy of secure implementations. Instead, all my numeric fields are simple uint32s. I expect the overhead to be negligible and users not to need more than 4bn messages anyway.

There is no logging since the provided interface does not include any verbosity flag or logger. Except in Serve which is not a reusable component anyway. Serve follows the http.Serve semantic and closes the Listener.

The replay attack protection requires deriving the public key from the private one, using `curve25519.ScalarBaseMult`. I know I'm not supposed to use other packages, but I hope this will be admitted since it's basically the body of `nacl/box.GenerateKey`.
